analytic

# variables go here...
# only floats supported right now.
# [type] [name] [min val] [max val] [default val]

::begin parameters
float f0 0 1 .1
float rough 0.01 1 0.1
::end parameters


# Then comes the shader. This should be GLSL code
# that defines a function called BRDF (although you can
# add whatever else you want too, like sqr() below).

::begin shader

float sqr(float x) { return x*x; }

float Beckmann(float m, float t)
{
    float M = m*m;
    float T = t*t;
    return exp((T-1)/(M*T)) / (M*T*T);
}

float Fresnel(float f0, float u)
{
    // from Schlick
    return f0 + (1-f0) * pow(1-u, 5);
}

float D_Exponential(float c, float t)
{
    return exp(-t/c);
}

float G1_GGX(float Ndotv, float alphaG)
{
    return 2/(1 + sqrt(1 + alphaG*alphaG * (1-Ndotv*Ndotv)/(Ndotv*Ndotv)));
}


vec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y )
{
    const float PI = 3.14159265358979323846;
	// compute the half vec3
    vec3 H = normalize( L + V );

    float NdotH = dot(N, H);
    float VdotH = dot(V, H);
    float NdotL = dot(N, L);
    float NdotV = dot(N, V);
	float LdotH = dot(L, H);
    
	vec3 Cdiff = vec3(1.0);
	
	vec3 diffuse = (Cdiff) * ( 1 - Fresnel( f0, VdotH ) );
	
	float D = D_Exponential( rough, acos(NdotH) );
    D *= ( 1 + 4*rough*rough ) / ( 2*rough*rough * ( 1 + exp(-(PI/(2*rough) ))) * PI );
	
	float F = Fresnel( f0, LdotH );
	float alphaG = 0.001f;
	float G = G1_GGX(NdotL, alphaG) * G1_GGX(NdotV, alphaG);
	float denom = 1.f / 4.0f * NdotL*NdotV;
	
	
	vec3 val = diffuse + vec3(D*F*G * denom);
    return vec3(val);
}

::end shader
